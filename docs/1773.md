# 人工智能中的阿尔法贝塔剪枝是什么？

> 原文:[https://www.edureka.co/blog/alpha-beta-pruning-in-ai](https://www.edureka.co/blog/alpha-beta-pruning-in-ai)

修剪这个词真的会让人想起砍掉树枝，或者对那些熟悉[数据科学](https://www.edureka.co/blog/data-science-tutorial/)的人来说，它会让人想起树的后期和预修剪。Alpha-beta 剪枝本质上是对无用分支的剪枝。我们将讨论以下几点:

*   [最小最大算法](#min-max)
*   [阿尔法-贝塔修剪](#pruning)

在这篇博客中，我们将回顾 alpha-beta 修剪，以及我们如何在多路径游戏中使用它来创建策略。这些路径中的每一条都会导致不同的结果。当我们有如此大量的棋步时(如在国际象棋或数独游戏中)，我们真的需要以一种明确的方式制定游戏策略。这种游戏最终会进化，并产生高得不可思议的可能结果。所以我们需要考虑如何选择最好的行动。这必须在不花费猫在地球上生存的时间的情况下实现。

## **最小最大算法**

就蛮力方法而言，minimax 算法更容易理解。它试图看到每一个可能的结果，然后试图优化手中的任何选项。

就像数独游戏一样，我们最终可以生成一棵由分支组成的树，其深度包含玩家在游戏中所有可能的移动。接下来，我们需要遍历这棵树。

![MinMax Algorithm - Alpha Beta Pruning](../Images/6d828db57d9e7efd49466eefe2c3b881.png)

向下的三角形表示树中的一个位置，在这个位置上，minimax 将最小化对手的优势。然而，向上的三角形是最小最大化用户优势的位置。

直觉上，要知道一个玩家的优势，首先需要知道哪条路通向胜利。这就是强力方法的用武之地。这实质上意味着该算法必须遍历树的底部，并经历每一个可能的移动。接下来，它必须分配某个权重(例如，赢了+1，输了-1)，并通过树向上传播这个权重。

<figure class="kg-card kg-image-card kg-card-hascaption">![MinMax](../Images/800a152b9ef1a5fc714e20a7205b56b1.png)</figure>

## **阿尔法-贝塔修剪**

阿尔法贝塔修剪是所有关于减少我们的搜索树的大小(修剪)。虽然强力方法更容易使用，但这并不意味着它是最佳方法。很多时候，人们不需要访问所有可能的分支机构来提出手头的最佳解决方案。

因此，我们需要为最小-最大算法提供一些停止标准，使用这些标准，一旦找到该级别的保证最小值或最大值，它将停止搜索树的某个区域。这将防止算法使用额外的计算时间，使其响应更快。

最初的最小-最大算法以从左到右的方式执行树的遍历，同时也到达树的最深可能深度。这本质上是一种深度优先的方法。然后，它会发现必须直接分配给它上面的节点的值，而不会查看树的其他分支。

因此，停止条件的添加使得最小-最大像以前一样做出决定，但是它优化了算法的性能方面。

在下图中，我们有一个树，每个节点分配有不同的分数。一些节点用红色阴影表示，表示没有必要查看它们。

在树的左下方，minimax 遍历底部 max 层的值 5 和 6。它确定必须将 5 分配给其正上方的最小级别。

但是，在查看了右最大级别分支的 7 和 4 之后，它意识到上面的最小级别节点必须被分配最大值 4。因为正好在第一个最小级别之上的第二个最大级别将取 5 到最多 4 之间的最大值，很明显它会选择 5。接下来，它将继续遍历树，在树的其他分支中执行完全相同的一组操作。

总之，我们可以很容易地理解 alpha-beta 剪枝是如何优于 min-max 算法的，以及这些算法是如何成为状态空间搜索技术的基础的，从而为解决此类问题的更高级方法铺平了道路。

至此，我们结束了[人工智能](https://www.edureka.co/blog/artificial-intelligence-tutorial/)文章中的 Alpha Beta 修剪。

*所以，本文基于 tensor flow[**AI 和深度学习**](https://www.edureka.co/ai-deep-learning-with-tensorflow) 课程由行业专业人士根据行业需求&需求策划。您将掌握 SoftMax 函数、自动编码器神经网络、受限玻尔兹曼机(RBM)等概念，并使用 Keras & TFLearn 等库。该课程由行业专家通过实时案例研究特别策划。*

有问题要问我们吗？请在“人工智能中的 Alpha Beta 剪枝”的评论部分提及，我们会给你回复。