# 关于微服务设计模式你需要知道的一切

> 原文：<https://www.edureka.co/blog/microservices-design-patterns>

在当今的市场上，[微服务](https://www.edureka.co/blog/what-is-microservices/)已经成为构建应用的首选解决方案。众所周知，它们可以解决各种挑战，但是，[熟练的专业人员](https://www.edureka.co/microservices-architecture-training)在使用这种架构时经常会面临挑战。因此，开发人员可以探索这些问题中的共同模式，并可以创建可重用的解决方案来提高应用程序的性能。因此，在这篇关于微服务设计模式的文章中，我将讨论构建成功的微服务所必需的顶级模式。

本文将涵盖以下主题:

*   [什么是微服务？](#WhatareMicroservices)
*   [用于设计微服务架构的原则](#PrinciplesUsedtoDesignMicroserviceArchitecture)
*   [微服务的设计模式](#DesignPatternsofMicroservices)

**什么是微服务？**

**微服务** ，又名 [***微服务架构***](https://www.edureka.co/blog/microservice-architecture/) ，是一种架构风格，将应用程序构建为小型自治服务的集合，围绕 **业务领域建模。**在微服务架构中，每个服务都是独立的，并且实现单一的业务功能。如果想对微服务有详细的了解，可以参考[我写的关于微服务架构的文章。](https://www.edureka.co/blog/microservices-tutorial-with-example)

**![What are Microservices - Microservices Design Patterns - Edureka](img/4511eb23a629d5238480b61611023da3.png)**

**用于设计微服务架构的原则**

用于设计微服务的原则如下:

1.  独立自主服务
2.  可量测性
3.  分散
4.  弹性服务
5.  实时负载平衡
6.  有效性
7.  通过 DevOps 集成持续交付
8.  无缝 API 集成和持续监控
9.  故障隔离
10.  自动供应

**微服务的设计模式**

### **聚合器模式**

计算世界中的聚合器指的是收集相关数据项并显示出来的网站或程序。因此，即使在微服务模式中，聚合器也是一个调用各种服务来获取所需信息或实现所需功能的基本网页。

此外，由于输出源在将整体架构分解为微服务时会被分割，当您需要通过组合来自多个服务的数据来输出时，这种模式被证明是有益的。因此，如果我们有两个服务，每个都有自己的数据库，那么一个具有唯一事务 ID 的聚合器将从每个单独的微服务收集数据，应用业务逻辑，并最终将其发布为一个 [REST](https://www.edureka.co/blog/what-is-rest-api/) 端点。稍后，收集的数据可以由需要收集的数据的相应服务使用。

骨料设计模式基于干燥原则。基于这一原则，您可以将逻辑抽象成一个复合的微服务，并将特定的业务逻辑聚合成一个服务。

例如，如果您考虑两个服务:服务 A 和 B，那么您可以通过向复合微服务提供数据来同时单独扩展这些服务。

### **![Aggregator - Microservices Design Patterns - Edureka](img/8dcfeda615089208b8abd4a31bc76e22.png)**

### **API 网关设计模式**

微服务的构建方式是每个服务都有自己的功能。但是，当应用程序被分解成小的自治服务时，开发人员可能面临的问题就很少了。这些问题可能如下:

1.  如何从多个微服务请求信息？
2.  不同的 UI 需要不同的数据来响应相同的后端数据库服务
3.  如何根据消费者需求从可重用的微服务转换数据
4.  如何处理多个协议请求？

这类问题的解决方案可能是 API 网关设计模式。API 网关设计模式不仅解决了上面提到的问题，还解决了许多其他问题。这种微服务设计模式也可以被认为是将请求路由到相关微服务的代理服务。作为聚合器服务的变体，它可以将请求发送到多个服务，并类似地将结果聚合回组合服务或消费者服务。API Gateway 还充当所有微服务的入口点，并为不同类型的客户端创建细粒度的 API。

借助 API 网关设计模式，API 网关可以将协议请求从一种类型转换为另一种类型。同样，它也可以卸载微服务的身份验证/授权责任。

因此，一旦客户端发送请求，这些请求将被传递到 API 网关，该网关充当将客户端请求转发到适当微服务的入口点。然后，在负载均衡器的帮助下，处理请求的负载，并将请求发送到相应的服务。微服务使用服务发现，服务发现作为一个向导来寻找它们之间的通信路由。然后，微服务通过无状态服务器相互通信，即通过 HTTP 请求/消息总线。

### **![API Gateway - Microservices Design Patterns - Edureka](img/f600042186822d6ca423b5b57fca6604.png)**

### **链式或责任链模式**

链式或责任链设计模式产生单个输出，它是多个链式输出的组合。因此，如果您有三个服务排成一个链，那么，来自客户端的请求首先由服务 a 接收，然后，该服务与下一个服务 B 通信并收集数据。最后，第二个服务与第三个服务通信以生成合并的输出。所有这些服务都使用同步 HTTP 请求或响应进行消息传递。此外，在请求通过所有服务并生成相应的响应之前，客户端不会得到任何输出。所以，它总是建议不要做一个长链，因为客户会等到链完成

您需要理解的另一个重要方面是，从服务 A 到服务 B 的请求可能与服务 B 到服务 C 的请求不同。同样，从服务 C 到服务 B 的响应可能与服务 B 到服务 A 的响应完全不同。

### **![Chained - Microservices Design Patterns - Edureka](img/6cbb0b1e73d5b0b3807b32104075ead1.png)**

### **异步消息传递设计模式**

从上面的模式来看，很明显，在同步消息传递中，客户端被阻塞或者必须等待很长时间。但是，如果您不希望消费者等待很长时间，那么您可以选择异步消息传递。在这种类型的微服务设计模式中，所有服务都可以相互通信，但它们不必按顺序相互通信。因此，如果您考虑 3 个服务:服务 A、服务 B 和服务 C。来自客户端的请求可以同时直接发送到服务 C 和服务 B。这些请求将在一个队列中。除此之外，请求还可以发送给服务 A，服务 A 的响应不必发送给请求所来自的服务。

### **![Asynchronous Messaging - Microservices Design Patterns - Edureka](img/1141ee665ee4465d958adcf811beff05.png)**

### **数据库或共享数据模式**

对于每个应用程序，都存在海量数据。因此，当我们将应用从整体架构分解为微服务时，注意到每个微服务都有足够的数据量来处理请求是非常重要的。因此，系统可以为每个服务提供一个数据库，也可以为每个服务提供一个共享数据库。您可以使用每个服务一个数据库和每个服务一个共享数据库来解决各种问题。这些问题可能如下:

*   数据重复和不一致
*   不同的服务有不同的存储要求
*   很少的业务事务可以查询数据，提供多种服务
*   数据的去规范化

嗯，要解决前三个问题，我认为您可以针对每个服务使用数据库，因为它将由微服务 API 本身访问。因此，每个微服务都有自己的数据库 ID，这样就可以防止系统中的其他服务使用这个特定的数据库。除此之外，为了解决去规范化的问题，您可以为每个服务选择共享数据库，为每个微服务对齐多个数据库。这将有助于您为分解为微服务的单片应用程序收集数据。但是，您必须记住，您必须将这些数据库限制为 2-3 个微服务；否则，扩展这些服务将是一个问题。

### **![Database - Microservices Design Patterns - Edureka](img/8fe979e9f0e2ba83f3179c2370d1c78e.png)**

### **事件采购设计模式**

事件源设计模式创建关于应用程序状态变化的事件。此外，这些事件被存储为一系列事件，以帮助开发人员跟踪何时进行了哪些更改。因此，借助这一点，您可以随时调整应用程序状态，以应对过去的更改。您还可以查询这些事件中的任何数据更改，并同时从事件存储中发布这些事件。事件发布后，您可以在表示层上看到应用程序状态的变化。

### **![Event Sourcing - Microservices Design Patterns - Edureka](img/b4606b00421e0e437ce78395efe12a6e.png)**

### **分支模式**

分支微服务设计模式是一种可以同时处理来自两个或更多独立微服务的请求和响应的设计模式。因此，与链式设计模式不同，请求不是按顺序传递的，而是传递给两个或更多互斥的微服务链。该设计模式扩展了聚合器设计模式，并提供了从多个链或单个链生成响应的灵活性。例如，如果您考虑一个电子商务应用程序，那么您可能需要从多个来源检索数据，这些数据可能是来自各种服务的数据的协作输出。因此，您可以使用分支模式从多个来源检索数据。

### **![Branch - Microservices Design Patterns - Edureka](img/83e814855da872b853e459bbf02773ac.png)**

### **命令查询责任分离器(CQRS)设计模式**

每个微服务设计要么每个服务模型有一个数据库，要么每个服务有一个共享数据库。但是，在每服务数据库模型中，我们不能实现查询，因为数据访问仅限于一个数据库。因此，在这种情况下，你可以使用 CQRS 模式。根据这个模式，应用程序将分为两部分:命令和查询。命令部分将处理所有与创建、更新、删除相关的请求，而查询部分将处理物化视图。物化视图通过使用上述事件源模式创建的一系列事件来更新。

### **![CQRS - Microservices Design Patterns - Edureka](img/ddd5780add839297c176b12cd4d3f3e8.png)**

### **断路器模式**

顾名思义，断路器设计模式用于在服务不工作时停止请求和响应过程。例如，假设一个客户端正在发送一个请求，请求从多个服务中检索数据。但是，由于一些问题，其中一个服务关闭了。现在，您将面临两个主要问题:第一，由于客户端不知道某个特定的服务正在关闭，因此请求将不断地发送到该服务。第二个问题是网络资源会耗尽，性能低，用户体验差。

因此，为了避免这样的问题，您可以使用断路器设计模式。在这种模式的帮助下，客户端将通过代理调用远程服务。这个代理基本上相当于一个电路屏障。因此，当故障数量超过阈值数量时，断路器会在特定时间段内跳闸。然后，所有调用远程服务的尝试都将在这个超时周期内失败。一旦该时间段结束，断路器将允许有限数量的测试通过，并且如果这些请求成功，断路器恢复到正常操作。否则，如果失败，则超时周期再次开始。

### **![Circuit Breaker - Microservices Design Patterns - Edureka](img/cf462d3d491f94de1dfc68ba84029126.png)**

### **分解设计模式**

开发微服务时，开发人员的想法是创建小型服务，每个服务都有自己的功能。但是，将应用程序分解成小的自治单元必须符合逻辑。因此，要将一个或大或小的应用程序分解成小的服务，您可以使用分解模式。

在这种模式的帮助下，您可以基于业务能力或者基于子域来分解应用程序。例如，如果您考虑一个电子商务应用程序，那么如果您按业务功能分解，您可以为订单、支付、客户、产品提供单独的服务。

但是，在相同的场景中，如果您通过分解子域来设计应用程序，那么您可以为每个类提供服务。这里，在这个例子中，如果你把客户看作一个类，那么这个类将用于客户管理、客户支持等。因此，为了进行分解，您可以使用领域驱动的设计，通过这种设计，整个领域模型被分解成子领域。然后，这些子域中的每一个都将有它们自己特定的模型和范围(有界上下文)。现在，当开发人员设计微服务时，他/她将围绕范围或有限的上下文来设计这些服务。

虽然这些模式对您来说可能听起来可行，但对于大型的整体应用程序来说并不可行。这是因为对于大型应用程序来说，确定子域和业务能力并不是一件容易的事情。因此，分解大型单片应用程序的唯一方法是遵循 Vine 模式或 Strangler 模式。

**扼杀者模式或藤蔓模式**

扼杀者模式或藤蔓模式是基于对藤蔓的类比，藤蔓基本上扼死了它所缠绕的树。因此，当这种模式应用于 web 应用程序时，每个 URI 调用都会来回调用，服务会被分解到不同的域中。这些域将作为单独的服务托管。

根据扼杀者模式，两个独立的应用程序将在同一个 URI 空间中并排存在，一个域将在某个时刻被考虑在内。因此，最终，新的重构应用程序会包围或扼杀或替换原始应用程序，直到您可以关闭整体应用程序

所以，朋友们，我们就此结束这篇关于微服务设计模式的文章。我希望你已经理解了设计微服务的顶级模式。*如果您希望学习微服务并构建自己的应用程序，那么请查看我们的 **[微服务架构培训](https://www.edureka.co/microservices-architecture-training)** ，它附带有讲师指导的现场培训和真实项目体验。本培训将帮助您深入了解微服务，并帮助您掌握该主题。*

有问题要问我们吗？请在“  **微服务设计模式**的评论区提出来，我会回复你的。